---
title: 树
---

![](https://vp-blog-img.oss-cn-shanghai.aliyuncs.com/2021/algorithm/leetcode/1.4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91.png)

## 二叉树

- 特性

- 二叉树是指满足以下要求的树：

1. 它可以没有根结点，作为一棵空树存在

2. 如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树


二叉树不能被简单定义为每个结点的度都是2的树。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的

### 满二叉树

叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点。上文中的图就是满二叉树。

### 完全二叉树

- 特性

1. 从第一层到倒数第二层，每一层都是满的，也就是说每一层的结点数都达到了当前层所能达到的最大值

2. 最后一层的结点是从左到右连续排列的，不存在跳跃排列的情况（也就是说这一层的所有结点都集中排列在最左

堆其实就是一种完全二叉树，一般采用堆存储方式是数组

### 二叉搜索树

- 特性

1. 是一棵空树
2. 是一棵由根结点、左子树、右子树组成的树，同时左子树和右子树都是二叉搜索树，且左子树上所有结点的数据域都小于等于根结点的数据域，右子树上所有结点的数据域都大于等于根结点的数据域

满足以上两个条件之一的二叉树，就是二叉搜索树。

BST-> 中序遍历是递增的

### 平衡二叉树（AVL 树）

- 特性

是任意结点的左右子树高度差绝对值都不大于1的二叉搜索树。

### Trie 树

Google、百度一类的搜索引擎强大的关键词提示功能的背后，最基本的原理就 Trie 树，通过空间换时间，利用字符串的公共前缀，降低查询的时间以提高效率。除此之外，还有很多应用，比如：IP 路由中使用了 Trie 树的最长前缀匹配算法，利用转发表选择路径以及 IDE 中的智能提示等。

### B+ 树

我们知道，将索引存储在内容中，查询速度是比存储在磁盘中快的。但是当数据量很大的情况下，索引也随之变大。内存是有限的，我们不得不将索引存储在磁盘中。那么，如何提升从磁盘中读取的效率就成了工程上的关键之一。
大部分关系型数据库的索引，比如 MySQL、Oracle，都是用 B+ 树来实现的。B+ 树比起红黑树更适合构建存储在磁盘中的索引。B+ 树是一个多叉树，在相同个数的数据构建索引时，其高度要低于红黑树。当借助索引查询数据的时，读取 B+ 树索引，需要更少的磁盘 IO 次数。
一个 m 阶的 B 树满足如下特征：

每个节点中子节点的个数 k 满足 m > k > m/2，根节点的子节点个数可以不超过 m/2通过双向链表将叶子节点串联在一起，方便按区间查找m 叉树只存储索引，并不真正存储数据一般情况，根节点被存储在内存中，其他节点存储在磁盘中

### 树的遍历（前、中、后、层次）

- 前序遍历（根->左->右）

对于二叉树中的任意一个节点，先打印该节点，然后是它的左子树，最后右子树


```js
var preorderTraversal =function(root,array=[]){
    if(root){
        //递归实现
        array.push(root.val);
        preorderTraversal(root.left,array)
        preorderTraversal(root.right,array)
    }
    return array;
}

```

- 中序遍历(左->根->右)

对于二叉树中的任意一个节点，先打印它的左子树，然后是该节点，最后右子树

```js
//递归实现

var inorderTraversal= function(root,array=[]){
    if(root){
        inorderTraversal(root.left,array)
        array.push(root.val)
        inorderTraversal(root.right, array);
    }
    return array
}

```

- 后序遍历(左->右->根)

对于二叉树中的任意一个节点，先打印它的左子树，然后是右子树，最后该节点


```js
    var postorderTraversal = function (root, array = []) {
      if (root) {
        postorderTraversal(root.left, array);
        postorderTraversal(root.right, array);
        array.push(root.val);
      }
      return array;
    };

```

## 高频题

![](https://vp-blog-img.oss-cn-shanghai.aliyuncs.com/2021/algorithm/leetcode/tree-1.png)

![](https://vp-blog-img.oss-cn-shanghai.aliyuncs.com/2021/algorithm/leetcode/tree-2.png)

### [反转二叉树(简单)](https://leetcode-cn.com/problems/invert-binary-tree/)

- 递归

1. 从根节点开始，递归的对树进行遍历。
2. 从叶子结点开始进行翻转。
3. 左右子树都已经翻转后，交换两棵子树的位置即可完成全部的翻转。

```js
    const invertTree =function (root){
        if(root === null){
            return null
        } 
        invertTree(root.left)
        invertTree(root.right)
        const temp=root.left
        root.left= root.right
        root.right =temp     
        return root
    }
//时间复杂度: O(n)
//空间复杂度: O(n)    
```

### [相同的树(简单)](https://leetcode-cn.com/problems/same-tree/)

- 深度优先搜索DFS

1. 如果两棵树都为空,则它们相同返回true
2. 如果两个二叉树中有一个为空，则它们不同返回false
3. 如果两个二叉树都不为空,首先判断根节点是否相同,不同则返回false
4. 如果两个二叉树的根节点相同，则分别递归判断其左右子树是否相同

```js
const isSameTree =function(p,q){
    if(p ===null && q===null) return true
    if(p === null || q===null) return false
    if(p.val !==q.val) return false
    return isSameTree(p.left,q.left) && isSameTree(p.right,q.right)
}

//时间复杂度: O(min(m, n))
//空间复杂度: O(min(m, n))
```

### [对称二叉树(简单)](https://leetcode-cn.com/problems/symmetric-tree/)

- 递归

先明确,所谓"对称",也就是两个树的根节点相同且

1. 第一个树的左子树与第二个树的右子树镜像对称
2. 第一个树的右子树与第二个树的左树镜像对称

```js
const isSymmetric= function (root){
    if(root ===null){
        return true
    }
    return isEqual(root.left,root.right)
}
const isEqual = function (left,right)
{
    //递归终止条件
    if(left === null && right ===null) return true
    if(left === null || right === null )return false
    //比较左右子树的root 值以及左右子树 是否对称
    return left.val === right.val && isEqual(left.left, right.right)
    && isEqual(left.right,right.left)
}
//时间复杂度: O(n)
//空间复杂度: O(n)
```

### [二叉树的最大深度(简单)](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

- DFS 深度优先搜索

树的深度= 左右子树的最大深度+1

```js
const maxDepth =function(root){
    if(!root){
        return 0
    }else{
        const left = maxDepth(root.left)
        const right = maxDepth(root.right)
        return Math.max(left,right)+1
    }
}

//时间复杂度: O(n)
//最坏空间复杂度: O(height), height 表示二叉树的高度

```

- BFS 广度优先搜索

层序遍历时记录树的深度

```js
const maxDepth = function(root) {
    //层数
    let depth = 0
    if (root === null) {
        return depth
    }
    const queue = [root]
    while (queue.length) {
        let len = queue.length
        while (len--) {
            const cur = queue.shift()
            cur.left && queue.push(cur.left)
            cur.right && queue.push(cur.right)
        }
        depth++
    }
    return depth
};

//时间复杂度: O(n)
//空间复杂度: O(n)

```

### [平衡二叉树（简单）]（https://leetcode-cn.com/problems/balanced-binary-tree/）

- 平衡二叉树定义：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1

1. 如果遍历完成，还没有高度差超过1的左右子树，则符合条件
2. 判断左右子树高度差，超过1则返回false
3. 递归左右子树
4. 封装获取子树高度函数getHeight


```js

const isBalanced =function (root){
        if(!root) return true
        if(Math.abs(getHeight(root.left) - getHeight(root.right))>1){
            return false
        }
        return isBalanced(root.left) && isBalanced(root.right)
        function getHeight(root){
            if(!root) return 0
            return Math.max(getHeight(root.left),getHeight(root.right))+1
        }   
}

//时间复杂度：O(n)
//空间复杂度：O(n)

```

### [将有序数组转换为二叉搜索树（简单）](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

- 递归

1. 二叉搜索树的中序遍历是升序的，本题中给出的数组刚好是升序的，相当于通过中序遍历恢复二叉搜索树
2. 可以选择升序序列中的任意位置的元素作为根节点，该元素左边的升序序列构建左子树，右边的升序序列构建右子树
3. 题目又要求高度平衡，所以我们需要选择升序序列的中间位置的元素作为根节点即可

```js
const sortedArrayToBST =function (nums){

    const buildTree = (arr,left,right)=>{
        if(left > right){
            return null
        }
        let mid = Math.floor(left+(right -left)/2)
        let root = new TreeNode(arr[mid])
        root.left = buildTree(arr,left,mid-1)
        root.right = buildTree(arr,mid+1,right)
        return root
    }
    return buildTree(nums,0,nums.length-1)
}
// 时间复杂度O(n)
// 空间复杂度O(n)
```

### [路径总和(简单)](https://leetcode-cn.com/problems/path-sum/)

- 递归

1. 处理边界，节点不存在时返回false
2. 左右子树都不存在时代表是叶子节点，判断是否符合条件
3. 递归左右子树时进行转换，看能否找到 targetSum -root.val 的路径

```js
const hasPathSum =(root,targetSum){
    if(root === null){
        return false
    }
    if(root.left === null && root.right === null){
        return root.val === targetSum
    }
    return hasPathSum(root.left,targetSum - root.val) || hasPathSum(root.right,targetSum - root.val)
}

//时间复杂度: O(n)
//空间复杂度: O(H)，H 是树的高度

```

### [二叉树的直经(简单)](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

- 递归dfs

一棵二叉树的直径长度是任意两个结点路径长度中的最大值
这条路径可能穿过也可能不穿过根结点

- 两个公式

1. 最长路径=左子树最长路径 +右子树最长路径 +1（根结点）
2. 高度(最大深度) = 左右子树中的最大深度+1（根结点）

```js
const diameterOfBinaryTree =function (root){
    let ans =1
    function depth(node）{
        if(node ===null) return 0
        let L =depth(node.left)
        let R =depth(node.right)
        ans =Math.max(ans,L+R+1)
        return Math.max(L,R)+1
    }
    depth(root)
    return ans -1
}
// 时间复杂度: O(n)
// 空间复杂度: O(H)，H 为二叉树的高度
```

### [二叉树到层序遍历(中等)](https://github.com/Geekhyt/javascript-leetcode/issues/18)

- DFS 深度优先遍历

```js
const levelOrder =function (root){
    if(!root) return []
    const res =[]
    dfs(root,0,res)
    return res
}

const dfs =function (root,depth,res){
     if(!root) return 
     if(!res[depth]) {
         res[depth]=[]
     }
     res[depth].push(root.val)//存入每层的节点值
     dfs(root.left,depth +1,res)
     dfs(root.right,depth +1,res)
}

```

- BFS 广度优先遍历

根据层次 返回其对应的结果集合

1. 边界处理，初始化队列 queue 和存放结果的数组 res。
2. 外层循环遍历层级结构，内层循环遍历每一层的子节点。
3. 遍历时需要记录当前层的遍历次数 len 以及当前层的节点数组 arr。
4. 取得 node 依次出队，并依次存入当前层的节点数组中。
5. 若存在左右子节点，则依次入队，并更新 len。
6. 遍历完后返回结果 res。

```js
const levelOrder =function(root){
    if(!root) return []
    const queue =[root]
    const res =[]
    while (queue.length>0){
        const arr =[]
        let len =queue.length
        while(len){
            let node =queue.shift()
            arr.push(node.val)
            if(node.left){
                queue.push(node.left)
            }
            if(node.right){
                queue.push(node.right)
            }
            len --
        }
        res.push(arr)
    }
    return res
}
//时间复杂度: O(n)
//空间复杂度: O(n)
```

### [验证二叉搜索树(中等)](https://leetcode-cn.com/problems/validate-binary-search-tree)

- 中序遍历

二叉搜索树需要满足以下三条件：

- 节点的左子树只包含小于当前节点的数
- 节点的右子树只包含大于当前节点的数
- 所有左子树和右子树自身必须也是二叉搜索树

1. 二叉搜索树在中序遍历得到序列一定是升序
2. 进行中序遍历，判断当前节点是否大于前一个节点
3. 如果比前一个大，说明满足，则继续遍历，否则直接返回 false

```js
const isValidBST =function (root){
    let prev = -Infinity
    let result = true 
    function inorder(root){
        if(root === null){
            return 
        }
        inorder(root.left)
        if(root.val<=prev){
            result =false
            return 
        }
        prev =root.val
        inorder(root.right)
    }
    inorder(root)
    return result
}
```

## 参考链接

[非线性表（树、堆)](https://github.com/biaochenxuying/blog/issues/37)
[小白都可以看懂对树与二叉树](https://github.com/sisterAn/JavaScript-Algorithms/issues/39)
[“树”业有专攻](https://juejin.cn/post/6844904199050756110#heading-13)
[力扣++树](https://leetcode-solution.cn/solutionDetail?url=https%3A%2F%2Fapi.github.com%2Frepos%2Fazl397985856%2Fleetcode%2Fcontents%2Fthinkings%2Ftree.md&type=1)
