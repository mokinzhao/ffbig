---
title: 链表
---

## 特性

链表的插入/删除效率较高，而访问效率较低

- 高效的增删操作

- 麻烦的访问操作

## 链表有环

- 解法一 (暴力法 map)

- 解法二 (标记法)

```js
const hasCycle = function (head){
     while (head){
        if(head.flag) return true
        head.flag=true
        head=head.next
     }
     return false
}
//时间复杂度：O(n)

//空间复杂度：O(n)
```

- 解法三（快慢指针）

```js
const hasCycle= function(head){
    //边界判断
    if(!head|| !head.next){
        return false
    }
    //快指针
    let fast =head.next.next
    //慢指针
    let slow =head.next
    while (fast!==slow){
        if(!fast || !fast.next) return false
        fast =fast.next.next
        slow =slow.next
    }
    return true 
}
//时间复杂度：O(n)

//空间复杂度：O(1)
```

- 解法四（JSON.stringify()）

```js
//利用 JSON.stringify() 不能序列化含有循环引用的结构
const hasCycle= function (head){
  try{
      JSON.stringify(head)
      return false
  }
  catch(err){
      return true
  }
}

//时间复杂度：O(n)

//空间复杂度：O(n)

```

## 链表中环的入口节点

给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null

### flag标记法

```js
const detectCycle = function(head) {
    while(head){
        if(head.flag){
            return head;
        }else{
            head.flag = true;
            head = head.next;
        }
    }
    return null;
};
```

### 快慢指针

声明两个指针 P1 P2

1. 判断链表是否有环： P1 P2 从头部出发，P1走两步，P2走一步，如果可以相遇，则环存在

2. 从环内某个节点开始计数，再回到此节点时得到链表环的长度 length

3. P1、P2 回到head节点，让 P1 先走 length 步,当P2和P1相遇时即为链表环的起点

```js
function EntryNodeOfLoop(pHead){
    if(!pHead||!pHead.next){
        return null;
    }
    let P1 =pHead.next;
    let P2 =pHead.next.next;
    // 1.判断是否有环
    while(P1 !=P2){
        if(P2===null || P2.next ===null){
            return null
        }
        P1 =P1.next;
        P2 =P2.next.next;
    }
    // 2.获取环的长度
    let temp =P1;
    let length =1;
    P1= P1.next;
    while (temp !=P1){
        P1=P1.next;
        length++
    }
    // 3.找公共节点
    P1=P2=pHead;
    while(length-- >0){
        P2=P2.next
    }
    while (P1 !=P2){
        P1=P1.next;
        P2=P2.next;
    }
    return P1
}
```

## 反转链表

- 迭代法

时间复杂度: O(n)

空间复杂度: O(1)

```js
const reverseList=function(head){
    //初始化前驱节点为null
    let pre =null;
    //初始化目标节点为头节点
    let cur =head;
    //只要目标节点不为nul,遍历就得继续
    while(cur !==null){
        //记录一下 next 节点
        let next = cur.next;
        //反转指针
        cur.next=pre;
        //pre 往前走一步
        pre=cur
        // cur 往前走一步
        cur =next
    }
    //反转结束后,pre 就会变成链表头节点
    return pre
}

```

- 递归

时间复杂度: O(n)

空间复杂度: O(n)

```js
const reverseList= function(head){
 if(!head|| !head.next) return head
 //记录当前节点的下一个节点
 let next =head.next;
 let reverseHead =reverseList(next);
 //操作指针进行反转
 head.next =null;
 next.next =head;
 return reverseHead
}

```

## 合并两个有序链表（简单）

- 思路

1. 使用递归来解题
2. 将两个链表头部较小的一个与剩下的元素合并
3. 当两条链表中的一条为空时终止递归

```js
//时间复杂度：O(m+n)
//空间复杂度：O(m+n)

const mergeTwoList =function (l1,l2){
    if(l1===null){
        return l2
    }
    if(l2===null){
        return l1
    }
    if(l1.val<l2.val){
        l1.next=mergeTwoList(l1.next,l2)
        return l1
    }else{
        l2.next=mergeTowList(l1,l2.next)
        return l2
    }

}


```

## 删除链表的节点

- 思路

1. 定位节点： 遍历链表，直到 head.val == val 时跳出，即可定位目标节点。
2. 修改引用： 设节点 cur 的前驱节点为 pre ，后继节点为 cur.next ；则执行 pre.next = cur.next ，即可实现删除 cur 节点。

- 流程

1. 特例处理： 当应删除头节点 head 时，直接返回 head.next 即可。
2. 初始化： pre = head , cur = head.next 。
3. 定位节点： 当 cur 为空 或 cur 节点值等于 val 时跳出。

保存当前节点索引，即 pre = cur 。

遍历下一节点，即 cur = cur.next 。

4. 删除节点： 若 cur 指向某节点，则执行 pre.next = cur.next ；若 cur 指向 null ，代表链表中不包含值为 val 的节点。

5. 返回值： 返回链表头部节点 head 即可。


```js
//时间复杂度 O(N):N 为链表长度，删除操作平均需循环 N/2N/2 次，最差 NN 次。 
//空间复杂度 O(1): cur, pre 占用常数大小额外空间。

const deleteNode=function(head,val){
    if(head.val==val){
        return head.next
    }
    let pre =head,cur=head.next
    while(cur!=null && cur.val !=val){
        pre=cur;
        cur=cur.next;
    }
    if(cur!=null) pre.next=cur.next
    return head
}

```

## 参考链接

[面试链表不再怕](https://juejin.cn/post/6850037259350376461#heading-2)
