---
title: 栈、队列
---

## 概念

- Stack:先入后出；添加、删除皆为 O(1),查询为O(n)

- Queue: 先入先出；添加、删除皆为O(1),查询为O(n)

若题目中涉及括号问题，则很有可能和栈相关

## 栈

### 判断有效括号(简单)

```js
//用stack实现
const isValid= function (s){
    if(!s)return true;
    let map={
        '{':'}',
        '[':']',
        '(':')'
    }
    let stack=[];
    for(let i =0;i<s.length;i++){
        //缓存单个字符
        const ch=s[i];
        //判断是否是左括号，这里我为了实现加速，没有用数组的includes方法，手写判断逻辑
        if(ch==='{'||ch==='['||ch==='('){
            stack.push(map[ch])
        }
        //若不是左括号，且栈顶的左括号没有和当前字符匹配上，那么判为无效
        else{
            //若栈不为空，且栈顶的左括号没有和当前字符匹配上，那么判为无效
            if(!stack.length||stack.pop()!==ch){
                return false
            }
        }
    }
    return !stack.length
}

//简写
const isValid= function(s){

    let map={
        '{':'}',
        '(':')',
        '[':']'
    }
    let stack=[]
    for(let i=0;i<s.length;i++){
        if(map[s[i]]){
            stack.push(s[i])
        }else if(s[i] !== map[stack.pop()]){
            return false
        }
    }
    return stack.length === 0
}

```

### 每日温度(中等)

```js
const  dailyTemperatures = function (array){
    const len =array.length
    const stack=[]
    const res=(new Array(len).fill(0))// 初始化结果数组。注意数组定长，占位为0
    for(let i= 0; i<len; i++){
        //若栈不为0，且存在打破递减趋势的温度值
        while(stack.length&& array[i]> array[stack[stack.length-1]]){
            //将栈顶温度值对应的索引出栈
            const top= stack.pop();
            //计算 当前栈顶温度值与第一个离于它的温度值的索引差值
            res[top]=i-top
        }
        // 注意栈里存的不是温度值，而是索引值，这是为了后面方便计算
        stack.push(i)   
    }
    //返回数组结果
    return res
}

```

- 栈的设计——“最小栈”问题

```js
const MinStack = function() {
    this.stack = [];
    // 定义辅助栈
    this.stack2 = [];
};

/** 
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
    this.stack.push(x);
    // 若入栈的值小于当前最小值，则推入辅助栈栈顶
    if(this.stack2.length == 0 || this.stack2[this.stack2.length-1] >= x){
        this.stack2.push(x);
    }
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    // 若出栈的值和当前最小值相等，那么辅助栈也要对栈顶元素进行出栈，确保最小值的有效性
    if(this.stack.pop() == this.stack2[this.stack2.length-1]){
        this.stack2.pop();
    }
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.stack[this.stack.length-1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
    // 辅助栈的栈顶，存的就是目标中的最小值
    return this.stack2[this.stack2.length-1];
};

```

## 队列

- 用栈实现队列

```js
/**
 * 初始化构造函数
 */
const MyQueue = function () {
  // 初始化两个栈
  this.stack1 = [];
  this.stack2 = [];
};

/**
* Push element x to the back of queue.
* @param {number} x
* @return {void}
*/
MyQueue.prototype.push = function (x) {
  // 直接调度数组的 push 方法
  this.stack1.push(x);
};

/**
* Removes the element from in front of queue and returns that element.
* @return {number}
*/
MyQueue.prototype.pop = function () {
  // 假如 stack2 为空，需要将 stack1 的元素转移进来
  if (this.stack2.length <= 0) {
    // 当 stack1 不为空时，出栈
    while (this.stack1.length !== 0) {
      // 将 stack1 出栈的元素推入 stack2
      this.stack2.push(this.stack1.pop());
    }
  }
  // 为了达到逆序的目的，我们只从 stack2 里出栈元素
  return this.stack2.pop();
};

/**
* Get the front element.
* @return {number}
* 这个方法和 pop 唯一的区别就是没有将定位到的值出栈
*/
MyQueue.prototype.peek = function () {
  if (this.stack2.length <= 0) {
    // 当 stack1 不为空时，出栈
    while (this.stack1.length != 0) {
      // 将 stack1 出栈的元素推入 stack2
      this.stack2.push(this.stack1.pop());
    }
  }
  // 缓存 stack2 的长度
  const stack2Len = this.stack2.length;
  return stack2Len && this.stack2[stack2Len - 1];
};

/**
* Returns whether the queue is empty.
* @return {boolean}
*/
MyQueue.prototype.empty = function () {
  // 若 stack1 和 stack2 均为空，那么队列空
  return !this.stack1.length && !this.stack2.length;
};
```


- 双端队列

