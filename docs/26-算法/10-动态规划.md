---
title: 动态规划
---

## 概念

- 最优判断+回退

## 应用场景

- 解决最值问题

- 最优子结构

- 重叠子问题

## 思维分析

- 步骤

1. 递归+记忆化 -> 递推

2. 状态定义：opt[n],dp[n],fib[n]

3. 状态转移方程：opt[n]= best_of(opt[n-1],opt[n-2],...)

4. 最优子结构

- 难点

1. 状态转移方程不好确定

2. 已知的状态可能不明显

3. 递归转迭代，一部分同学可能不知道怎么转（这个就是纯粹的编程基础问题了，多写多练哈）


- 分析方法

1. 递归思想明确树形思维模型：找到问题终点，思考倒退的姿势，往往可以帮助你更快速地明确状态间的关系
2. 结合记忆化搜索，明确状态转移方程
3. 递归代码转化为迭代表达（这一步不一定是必要的，1、2本身为思维路径，而并非代码实现。若你成长为熟手，2中分析出来的状态转移方程可以直接往循环里塞，根本不需要转换）。


## 爬楼梯 (简单)

- 递推公式 f(n)=f(n-1)+ f(n-2)

```js
const climbStairs =function (n){
    // 初始化状态数组
    const f =[];
    // 初始化已知值
    f[1] = 1;
    f[2] = 2;

    // 动态更新每一层楼梯对应的结果
    for(let i =3; i<=n; i++){
        f[i] =f[i-2] +f[i-1]
    }
    // 返回目标值
    return f[n]

}
```

## 最少的硬币数目（中等）

- 递推公式 f(36) = Math.min(f(36-c1)+1,f(36-c2)+1,f(36-c3)+1......f(36-cn)+1)

```js
const coinChange =function (coins,amount){
    // 用于保存每个目标总额对应的最小硬币个数
    const f = []
    // 提前定义已知情况
    f[0] =0
    //遍历 [1,amount] 这个区间的硬币总额
    for (let i =1; i<= amount;i++){
        //求的最小值，因此我们预设为无穷大，确保它一定会被更小的数更新
        f[i]=Infinity
        //循环 遍历每个可用硬币的面额
        for(let j =0;j<coins.length;j++){
            //若硬币面额小于目标总额，则问题成立
            if(i-coins[j]>=0){
                //状态转移方程
                f[i]=Math.min(f[i],f[i-coins[j]]+1)
            }
        }
    }
    //若目标总额对应的解为无穷大，则意味着没有一个符合条件的硬币总数来更新它，本题无解，返回-1
    if(f[amount]===Infinity){
        return -1
    }
    //若有解，直接返回解的内容
    return f[amount]
}

```

## 背包问题

- 状态转移方程: dp[i][v]=Math.max(dp[i-1][v],dp[i-1][v-w[i]]+c[i]);

```js
// 入参是物品的个数和背包的容量上限，以及物品的重量和价值数组
function knapsack(n,c,w,value){
    // dp 是动态规划的状态保存数组
    const dp=(new Array(c+1)).fill(0)
    // res 用来记录所有组合方案中的最大值
    let res =Infinity
    for(let i=1;i<=n;i++){
        for(let v=c;v>=w[i];v--){
            // 写出状态转移方程
            dp[v]=Math.max(dp[v],dp[v-w[i]+value[i]])
            // 即时更新最大值
            if(dp[v]>res){
                res= dp[v]
            }   
        }
    }
    return res
}

```

## 买卖股票类问题


## 子序列问题

### 最长上升子序列

```js
let lengthOfLIS= function (nums){
    let dp =[];
    let n =nums.length
    if(!n){
        return 0
    }
    dp[0]=1
    for(let i =1;i<n;i++){
        let num =nums[i]
        let max =1
        //j从 [0,i]依次可以和i 组成的最长上升子序列
        for(let j=0;j<i;j++){
            let prevNum=nums[j]
            if(num > prevNum){
                //循环中不断更新max值
                max=Math.max(max,dp[j]+i)
            }
        }
        dp[i]=max
    }

    return =Math.max(..dp)
}

```

### 最长回文子串问题

- 状态转移方程:

s[i] === s[j] && dp[i][j] = dp[i+1][j-1]

```js
const longestPalindrome =function (s){
    const len =s.length
    const dp= Array.from(new Array(len),()=> new Array(len).fill(0))
    let res =''
    for(let i =len-1; i>=0;i--){
        for(let j=i; j<len;j++){    
            dp[i][j]= s[i]===s[j]&&(j-i<2 || dp[i+1][j-1])
            if(dp[i][j]&&j-i+1>res.length){
                res=s.slice(i,j+1)
            }
        }
    }
    return res
}

```
