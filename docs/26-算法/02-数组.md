---
title: 数组
---


## N数之和

- 两数之和(简单)

```js
//暴力解法
const twoSum=function(nums,target){
    for(let i=0;i<nums.length;i++){
        for(let j=i+1;j<nums.length;j++){
            if(nums[i]+nums[j]==target){
                return[i,j]
            }
        }
    }
}

//求差-利用map
const twoSum=function(nums,target){
    const len=nums.length;
    const map=new Map()
    for(let i=0;i<len;i++){
        const diff= target-nums[i]
        if(map.has(diff)){
            return [map.get(diff),i]
        }
        map.set(nums[i],i)
    }
}

//求差-利用{}
const twoSum=function(nums,target){
    //边界判断
    if(nums.length<2)return nums
    //定义一个对象用于保存数据
    const object={}
    for(let i=0;i<nums.length;i++){
        const diff=target-nums[i]
        if(object[diff]!=undefined){
            return [object[diff],i]
        }
        object[nums[i]]=i
    }
}

```

- 三数之和(中等)

题目:
给定一个包含 n 个整数的数组nums，判断 nums 中是否存在三个元素a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元

- 解法一（暴力法-3重循环）




- 解法二（排序+左右指针）

解题:
1.为了方便去重，我们首先将数组排序
2.对数组进行遍历，取当前遍历的数nums[i]为一个基准数，遍历数后面的数组为寻找数组
3.在寻找数组中设定两个起点，最左侧的left(i+1)和最右侧的right(length-1)
4.判断nums[i] + nums[left] + nums[right]是否等于0，如果等于0，加入结果，并分别将left和right移动一位
5.如果结果大于0，将right向左移动一位，向结果逼近
5.如果结果小于0，将left向右移动一位，向结果逼近

```js
// 排序+快慢指针
const threeSum=function(nums){
        //边界判断
        if(!nums || nums.length < 3) return []
        //定义空数组
        const result=[];
        //排序
        nums.sort((a,b)=>a-b);
        for(let i=0;i<nums.length;i++){
            //跳过重复数字
            if(i&&nums[i]===nums[i-1]){continue}
            //左指针
            let left=i+1;
            //右指针
            let right = nums.length-1;
            while(left<right){
                const sum=nums[i]+nums[left]+nums[right]
                //大于0移动右指针
                if(sum>0){
                    right--;
                }else if(sum<0){
                    left++;
                }else{
                    result.push([nums[i],nums[left++],nums[right--]]);
                    //跳过重复数字
                    while(nums[left]===nums[left-1]){
                        left++;
                    }
                    while(nums[right]===nums[right+1]){
                        right--;
                    }
                }
            }
        }
        return result
}
```

- 四数之和(中等)
你已经经历了两数之和、三数之和，玩玩没想到，还有四数之和...
其实，后面还有五数之和，六数之和...
到这里其实我们就能发现一些规律，我们可以像三数之和那样，我们可以通过大小指针来逼近结果，从而达到降低一层时间复杂度的效果。
不管是几数之和，我们都用这种方法来进行优化。

```js
const fourSum= function(nums,target){
    //排除边界情况
    if(nums.length<4){
        return [];
    }
    //排序
    nums.sort((a,b)=>a-b);
    const result=[];
    for(let i = 0;i<nums.length-3;i++){
        if(i>0&& nums[i] ===nums[i-1]){
            continue;
        }
        if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target){
            break;
        }
        for(let j= i+1; j< nums.length-2;j++){
            if(j>i+1&&nums[j]===nums[j-1]){
                continue;
            }
            let left=j+1,
            right=nums.length-1;
        while(left<right){
            const sum=nums[i]+nums[j]+nums[left]+nums[right];
            if(sum===target){
            result.push([nums[i],nums[j],nums[left],nums[right]]);
            }
            if(sum<=target){
                while (nums[left]===nums[++left]);
            }else{
                while(nums[right]===nums[--right]);
            }
        }        
      }
    }
    return result;
}
```

## 判断有效括号

## 移动零

## 盛水最多的容器

- 左右指针


## 爬楼梯

- 递推公式 f(n)=f(n-1)+ f(n-2)
