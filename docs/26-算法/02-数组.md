---
title: 数组
---


## N数之和

- 两数之和(简单)

```js
//暴力解法 (On2)
const twoSum=function(nums,target){
    for(let i=0;i<nums.length;i++){
        for(let j=i+1;j<nums.length;j++){
            if(nums[i]+nums[j]==target){
                return[i,j]
            }
        }
    }
}

//求差-利用map(On)
const twoSum=function(nums,target){
    const len=nums.length;
    const map=new Map()
    for(let i=0;i<len;i++){
        const diff= target-nums[i]
        if(map.has(diff)){
            return [map.get(diff),i]
        }
        map.set(nums[i],i)
    }
}

//求差-利用{On}
const twoSum=function(nums,target){
    //边界判断
    if(nums.length<2)return nums
    //定义一个对象用于保存数据
    const object={}
    for(let i=0;i<nums.length;i++){
        const diff=target-nums[i]
        if(object[diff]!=undefined){
            return [object[diff],i]
        }
        object[nums[i]]=i
    }
}

```

- 三数之和(中等)

题目:
给定一个包含 n 个整数的数组nums，判断 nums 中是否存在三个元素a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元

1. 解法一（暴力法-3重循环 On3）

```js
const threeSum = function(nums) {
    //示例 nums:  [-1, -1, 0, 1, 2, -1, -4]
    let res = [];
    //不得不一开始就给数组排序, 这样好去掉重复的三元组
    //不然就会出现这种情况: [ -1, 0, 1 ], [ 0, 1, -1 ],  还是得排序后去重
    //排好序后, 重复的元素一定在一起, 当和前边的数相等时, 说明这个数已经查找过了, 就不必查找了
    // nums.sort((a, b) => a - b);  // 测试时, 别忘打开排序

    for (let i = 0; i < nums.length; i ++ ) {
        for (let j = i + 1; j < nums.length; j ++) {
            for (let k = j + 1; k < nums.length; k ++) {
                //在一开始nums没有排序的情况下, 发现做了这些处理后, 依然无法完全避免 重复的三元组
                if ( i > 0 && nums[i] == nums[ i - 1] ) continue;
                if ( j > i + 1 && nums[j] == nums[ j - 1] ) continue;
                if ( k > j + 1 && nums[k] == nums[ k - 1] ) continue;
                
                //如果在这里给 符合条件的三个数排序, 然后对比去重符合条件的 三元组, 这样更复杂了
                //所以最后发现在 一开始给整个数组排序还是比较简单的, 复杂度低的
                if (nums[i] + nums[j] + nums[k] == 0) {
                    res.push([ nums[i], nums[j], nums[k] ]);
                };
            }
        }
    };

    return res;
};
```

2. 解法二（排序+左右指针）On2

解题:
1.为了方便去重，我们首先将数组排序
2.对数组进行遍历，取当前遍历的数nums[i]为一个基准数，遍历数后面的数组为寻找数组
3.在寻找数组中设定两个起点，最左侧的left(i+1)和最右侧的right(length-1)
4.判断nums[i] + nums[left] + nums[right]是否等于0，如果等于0，加入结果，并分别将left和right移动一位
5.如果结果大于0，将right向左移动一位，向结果逼近
5.如果结果小于0，将left向右移动一位，向结果逼近

```js
// 排序+快慢指针
const threeSum=function(nums){
        //边界判断
        if(!nums || nums.length < 3) return []
        //定义空数组
        const result=[];
        //排序
        nums.sort((a,b)=>a-b);
        for(let i=0;i<nums.length;i++){
            //跳过重复数字
            if(i&&nums[i]===nums[i-1]){continue}
            //左指针
            let left=i+1;
            //右指针
            let right = nums.length-1;
            while(left<right){
                const sum=nums[i]+nums[left]+nums[right]
                //大于0移动右指针
                if(sum>0){
                    right--;
                }else if(sum<0){
                    left++;
                }else{
                    result.push([nums[i],nums[left++],nums[right--]]);
                    //跳过重复数字
                    while(nums[left]===nums[left-1]){
                        left++;
                    }
                    while(nums[right]===nums[right+1]){
                        right--;
                    }
                }
            }
        }
        return result
}
```

- 四数之和(中等)
你已经经历了两数之和、三数之和，玩玩没想到，还有四数之和...
其实，后面还有五数之和，六数之和...
到这里其实我们就能发现一些规律，我们可以像三数之和那样，我们可以通过大小指针来逼近结果，从而达到降低一层时间复杂度的效果。
不管是几数之和，我们都用这种方法来进行优化。

```js
//排序+双指针 On3
const fourSum= function(nums,target){
    //排除边界情况
    if(nums.length<4){
        return [];
    }
    //排序
    nums.sort((a,b)=>a-b);
    const result=[];
    for(let i = 0;i<nums.length-3;i++){
        if(i>0&& nums[i] ===nums[i-1]){
            continue;
        }
        if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target){
            break;
        }
        for(let j= i+1; j< nums.length-2;j++){
            if(j>i+1&&nums[j]===nums[j-1]){
                continue;
            }
            let left=j+1,
            right=nums.length-1;
        while(left<right){
            const sum=nums[i]+nums[j]+nums[left]+nums[right];
            if(sum===target){
            result.push([nums[i],nums[j],nums[left],nums[right]]);
            }
            if(sum<=target){
                while (nums[left]===nums[++left]);
            }else{
                while(nums[right]===nums[--right]);
            }
        }        
      }
    }
    return result;
}
```

## 盛水最多的容器

- 左右指针






## 移动零




## 爬楼梯

- 递推公式 f(n)=f(n-1)+ f(n-2)
